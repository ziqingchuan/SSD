export const shortAnswer = [
    {
        question: "简述面向对象设计原则及其定义",
        answer: "1. 单一职责原则（SRP）：一个对象只应包含单一职责，并且该职责被完整的封装在一个类中\n" +
            "2. 开闭原则（OCP）：一个软件实体应该对扩展开放，对修改关闭\n" +
            "3. 里氏代换原则（LSP）：所有引用基类的地方必须能透明地使用其子类的对象\n" +
            "4. 依赖倒置原则（DIP）：高层模块不应该依赖低层模块，二者都应该依赖其抽象（针对接口编程而不是针对实现）\n" +
            "5. 接口隔离原则（ISP）：使用多个专门的接口，而不使用单一的总接口\n" +
            "6. 合成复用原则（CRP）：尽量使用对象组合，而不是继承来达到复用的目的\n" +
            "7. 迪米特法则（LoD）/最小知识原则（LKP）：软件实体应当尽量少地与其他实体发生相互作用\n",
    },
    {
        question: "简述什么是设计模式？",
        answer: "设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。"
    },
    {
        question: "简述设计模式的分类",
        answer: "1. 按照目的分可分为创建型（关注对象的创建机制）、结构型（关注类和对象的组合）、行为型（关注对象之间的通信与职责分配）\n" +
            "2. 按照范围分可分为类模式（处理类和子类之间的关系，是静态的）、对象模式（处理对象之间的关系，是动态的）\n"
    },
    {
        question: "简要介绍一下策略模式",
        answer: "策略模式是一种对象行为型模式\n" +
            "符合开闭原则：无需对上下文进行修改就能够引入新的策略\n" +
            "定义：策略模式定义了一系列算法并把它们封装在一起，使他们可替换，策略使算法独立于使用该算法的客户端而变化\n" +
            "优点：避免了使用多重条件if-else语句,提高了项目的可维护性；\n"+
            "缺点：① 策略与上下文通信的开销；② 对象数量会增加\n" +
            "适用场景：① 许多相关的类仅在行为上有所不同；② 需要算法的不同变体；③ 一种算法使用了客户端不应该知道的数据",
    },
    {
        question: "简要介绍一下简单工厂模式",
        answer: "简单工厂模式是一种类创建型模式\n" +
            "违背了开闭原则：增加产品则要修改工厂类\n" +
            "定义：又称静态工程方法模式，可根据参数的不同返回不同类型的实例\n" +
            "优点：可以根据需求动态生成对象，而使用者不用知道怎么创建对象，各模块各司其职，降低了系统的耦合性\n" +
            "缺点：工厂职责过重，增加产品则要修改工厂类，不符合开闭原则\n" +
            "适用场景：工厂负责类创建的对象比较少时可以使用",
    },
    {
        question: "简要介绍一下工厂方法模式",
        answer: "工厂方法模式是一种类创建型模式\n" +
            "符合开闭原则：无需更改现有客户端代码，就可以在程序中引入新的产品类型。\n" +
            "定义：又称虚拟构造器模式、多态工厂，工厂父类负责定义创建产品对象的公共接口\n" +
            "优点：① 用户无需关注创建细节；② 可扩展性好，符合开闭原则\n" +
            "缺点：提高了系统的复杂度和抽象性，增加理解难度\n" +
            "适用场景：① 无法预知对象确切类别及其依赖关系时；② 希望用户能扩展内部组件时",
    },
    {
        question: "简要介绍一下抽象工厂模式",
        answer: "抽象工厂模式是一种对象创建型模式\n" +
            "符合开闭原则：向应用程序中引入新产品变体时，无需修改客户端代码\n" +
            "定义：提供一个创建一系列相关或相互依赖的对象的接口而无需指定他们具体的类\n" +
            "优点：隔离了具体类的生成，使用户不知道创建细节；实现了高内聚低耦合的设计目的\n" +
            "缺点：增加了系统的抽象性和理解难度；增加新的工厂和产品族容易但增加新的产品等级结构困难\n" +
            "适用场景：① 已经有一个基于一组抽象方法的类时；② 希望系统提供一个产品系列时可以使用",
    },
    {
        question: "简要介绍一下原型模式",
        answer: "原型模式是一种对象创建型模式\n" +
            "违背了开闭原则：对已有类进行克隆时，需要修改代码\n" +
            "定义：用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象\n" +
            "优点：可以克隆对象而无需与它们所属的具体类相耦合\n" +
            "缺点：对已有类进行克隆时，需要修改代码，违背了开闭原则\n" +
            "适用场景：需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类时",
    },
    {
        question: "简要介绍一下建造者模式",
        answer: "建造者模式是一种对象创建型模式\n" +
            "符合开闭原则：增加新的具体建造者无需修改原有类\n" +
            "定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n" +
            "优点：① 封装性好，构建和表示分离；② 扩展性好，增加新的具体建造者无需修改原有类；③ 客户端不必知道产品内部组成\n" +
            "缺点：产品必须有较多的内部变化时，建造者模式会产生较多的类，会导致设计难度增加\n" +
            "适用场景：① 产品内部模块间存在复杂的依赖关系，需要指定生成顺序时；② 隔离复杂对象的创建和使用，使得代码更容易维护",
    },
    {
        question: "简要介绍一下状态模式",
        answer: "状态模式是一种对象行为型模式\n" +
            "符合开闭原则：无需修改已有状态类和上下文就能引入新状态\n" +
            "定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类\n" +
            "优点：封装了转换规则，将不同状态的行为分割开，并可以方便地增加新的状态和转换\n" +
            "缺点：状态模式会增加对象的数目，状态模式的结构与实现都较为复杂\n" +
            "适用场景：① 对象的行为依赖于它的状态，并且不同的状态下行为有所不同；② 代码中包含大量与对象状态有关的条件语句时",
    },    {
        question: "简要介绍一下命令模式",
        answer: "命令模式是一种对象行为型模式\n" +
            "符合开闭原则：可以在不修改已有客户端代码的情况下在程序中创建新的命令\n" +
            "定义：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分开\n" +
            "优点：① 降低了系统的耦合度；② 新的命令可以很容易添加到系统中；③ 可撤销和恢复命令\n" +
            "缺点：可能产生大量的命令类\n" +
            "适用场景：① 系统需要将请求调用者和接收者解耦时；② 系统需要在不同时间指定、排队和执行请求时；③ 系统需要支持命令日志、撤销/重做操作时",
    },
    {
        question: "简要介绍一下观察者模式",
        answer: "观察者模式是一种对象行为型模式\n" +
            "符合开闭原则：无需修改发布者代码就能引入新的订阅者类/发布者类\n" +
            "定义：定义对象间的一对多依赖，当一个对象改变状态时，所有依赖于它的对象都得到通知并自动更新\n" +
            "优点：① 实现了表示层和数据逻辑层的分离；② 观察者模式支持广播通信；③ 可实现对象之间的松耦合关系\n" +
            "缺点：观察者过多时，通知广播效率低\n" +
            "适用场景：① 当一个对象状态的改变需要改变其他对象时；② 应用中的一些对象必须观察其他对象时",
    },
    {
        question: "简要介绍一下中介者模式",
        answer: "中介者模式是一种对象行为型模式\n" +
            "符合开闭原则：无需修改实际组件就能增加新的中介者\n" +
            "定义：用一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合关系减少，并可以独立地改变它们的行为\n" +
            "优点：① 简化了对象之间的通信；② 简化了对象之间的依赖关系；③ 减少了子类生成\n" +
            "缺点：中介者模式中对象过多，难以维护\n" +
            "适用场景：① 对象之间存在复杂的引用关系时；② 想通过一个中间类来封装多个类中的行为时",
    },
    {
        question: "简要介绍一下模板方法模式",
        answer: "模板方法模式是一种类行为型模式\n" +
            "通过子类抑制默认步骤实现可能会导致违反里氏替换原则\n" +
            "定义：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\n" +
            "优点：① 封装了不变部分，扩展可变部分；② 实现了对抽象方法的定义，避免了子类重复代码\n" +
            "缺点：每个不同的实现都需要一个子类，增加了类的数量，提高系统的复杂度\n" +
            "适用场景：① 只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时；② 多个类的算法除一些细微不同之外几乎完全一样时",
    },
    {
        question: "简要介绍一下适配器模式",
        answer: "适配器模式是一种类/对象结构型模式\n" +
            "符合开闭原则：只要客户端代码通过客户端接口与适配器进行交互，就能在不修改现有代码的情况下添加新类型的适配器\n" +
            "定义：将一个类的接口转换成客户希望的另一个接口，使得原本接口不兼容的两个类可以一起工作\n" +
            "优点：① 目标类与适配器类解耦；② 增加了类的透明性和复用性；③ 灵活性和扩展性很好\n" +
            "缺点：需要新增一系列接口和类，会让系统变得复杂\n" +
            "适用场景：① 希望复用一个类，但是其接口不符合系统的需要时；② 希望创建可复用的类用于一些彼此没有太大关联的类时",
    },
    {
        question: "简要介绍一下组合模式",
        answer: "组合模式是一种对象结构型模式\n" +
            "符合开闭原则：无需更改现有代码就可以在应用中添加新元素使其成为对象树的一部分\n" +
            "定义：将对象组合成树形结构以表示“部分-整体”的层次结构\n" +
            "优点：① 简化客户端代码；② 增加新类型对象时无需修改原有类；③ 简化了对复杂树形结构的遍历\n" +
            "缺点：对于功能差异较大的类， 提供公共接口会很困难\n" +
            "适用场景：① 希望表示对象的部分-整体层次结构时；② 希望客户端忽略组合对象与单个对象的不同，统一地使用组合结构时",
    },
    {
        question: "简要介绍一下桥接模式",
        answer: "桥接模式是一种对象结构型模式\n" +
            "符合开闭原则：可以新增抽象部分和实现部分， 且它们之间不会相互影响\n" +
            "定义：将抽象部分与实现部分分离，使它们可以独立变化\n" +
            "优点：① 实现细节和抽象化解耦；② 将实现细节对客户隐藏；③ 系统的可扩展性很高\n" +
            "缺点：增加了系统的复杂度\n" +
            "适用场景：① 希望在几个独立维度上扩展一个类；② 想要拆分或重组一个具有多重功能的庞杂类时",
    },
    {
        question: "简要介绍一下装饰器模式",
        answer: "装饰器模式是一种对象结构型模式\n" +
            "符合单一职责原则：可以将实现了许多不同行为的一个大类拆分为多个较小的类\n" +
            "定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更加灵活\n" +
            "优点：① 扩展对象功能；② 动态增加功能，不会对客户端代码产生任何影响\n" +
            "缺点：产生过多的装饰对象，会导致性能问题\n" +
            "适用场景：① 在不影响其他对象的情况下，动态增加功能时；② 用继承来扩展对象行为的方案难以实现或者根本不可行时",
    },
    {
        question: "简要介绍一下外观模式",
        answer: "外观模式是一种对象结构型模式\n" +
            "违背开闭原则：增加新的子系统可能需要修改外观类" +
            "定义：为多个复杂的子系统提供一个简单接口，使这些子系统更加容易被访问\n" +
            "优点：① 简化了子系统之间的依赖关系；② 减少了客户端所需处理的对象数目，并使得子系统更加容易使用\n" +
            "缺点：增加新的子系统可能需要修改外观类，违背了开闭原则\n" +
            "适用场景：① 客户端与多个子系统之间存在复杂的依赖关系时；② 希望为一个复杂的系统提供一个简单的接口时",
    },
    {
        question: "简要介绍一下享元模式",
        answer: "享元模式是一种对象结构型模式\n" +
            "定义：运用共享技术有效地支持大量细粒度的对象的复用\n" +
            "优点：① 相同对象只需保存一份，节省内存\n" +
            "缺点：① 需要牺牲执行速度换取内存；② 代码会变得非常复杂\n" +
            "适用场景：仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式",
    },
    {
        question: "简要介绍一下代理模式",
        answer: "代理模式是一种对象结构型模式\n" +
            "符合开闭原则：可以在不对服务或客户端做出修改的情况下创建新代理\n" +
            "定义：给某个对象一个代理，并由代理对象控制对原对象的引用\n" +
            "优点：① 可以在客户端毫无察觉的情况下控制服务对象；② 可以协调调用者与被调用者，降低了系统的复杂度\n" +
            "缺点：① 服务响应可能会有延迟；② 代码可能会变得复杂， 因为需要新建许多类\n" +
            "适用场景：延迟初始化 （虚拟代理）、访问控制 （保护代理）、本地执行远程服务 （远程代理）、记录日志请求 （日志记录代理）、缓存请求结果 （缓存代理）、智能引用代理",
    },
    {
        question: "简述策略模式和状态模式的区别",
        answer: "在状态模式中，具体状态类的方法参数中包含上下文对象，需要在状态处理完成后完成状态切换；\n" +
            "在策略模式中，直接对上下文类调用set方法设置策略即可，不涉及到策略的切换。",
    },
    {
        question: "简述防御式编程是什么？断言和错误处理有什么区别？",
        answer: "防御式编程：可以预见到问题所在，断定代码中每个阶段可能出现的错误，并作出相应的防范措施来防止类似的意外的发生。\n" +
            "区别：断言是在开发期间使用的、让程序在运行时进行自检的代码，是对开发人员的警告，通常是一个子程序或宏，断言不可以有副作用；\n" +
            "错误处理是对预先已经考虑到的错误按照流程进行处理。",
    },
    {
        question: "如何进行质量属性方案建模？",
        answer: "刺激、刺激源、响应、响应度量、环境、工件",
    },
    {
        question: "简述一下有哪些质量属性？",
        answer: "可用性、互操作性，可修改性，性能，安全性，可测试性，易用性，X-ability",
    },
    {
        question: "解释一下质量属性中的可用性？MTBF和MTTR是什么？如何计算可用性的响应度量？",
        answer: "可用性：通过减少故障来最大程度减少服务中断时间\n" +
            "MTBF；平均无故障时间；MTTR：平均维修时间\n" +
            "响应度量计算：MTBF/(MTBF+MTTR)",
    },
    {
        question: "为什么软件系统架构需要使用不同视图来文档化？",
        answer: "1. 不同视图支持不同用户与目标；\n" +
            "2. 不同视图将不同的质量属性问题暴露出不同程度",
    },
    {
        question: "描述4+1视图",
        answer: "逻辑视图：描述功能需求\n" +
            "过程视图：描述元素间的并发与交互\n" +
            "物理视图：描述主要过程与组件如何被映射到硬件上\n" +
            "开发视图：描述组件内部组织联系\n" +
            "架构用例：描述架构需求",
    },
    {
        question: "简要描述软件架构过程中的一般活动，以及每个活动的主要输入和输出",
        answer: "① 识别ASRs：输入：无；输出：优化的质量属性场景\n" +
            "② 架构设计：输入：优化的质量属性场景；输出：候选视图的草图\n" +
            "③ 架构文档化：输入：模式决定的草图；输出：View & Beyond\n" +
            "④ 架构评估：输入：View & Beyond、优化的质量属性场景；输出：View & Beyond\n",
    },
    {
        question: "简述软件架构可能来自哪里",
        answer: "NFRs、ASRs、质量需求、涉众与组织、技术环境、业务目标",
    },
    {
        question: "什么是ASRs？列出提取和识别ASR的四种来源和方法",
        answer: "ASRs：架构攸关需求，是对体系结构产生深远影响的需求。\n" +
            "来源与方法：① 从需求文档中收集；② 通过采访涉众收集；③ 通过了解业务目标来收集；④ 通过Utility Tree管理ASRs",
    },
    {
        question: "典型的软件架构文档包中应该包含哪些内容？简要描述每个组件及其用途。",
        answer: "应包含View和Beyond；\n" +
            "View：包含体系结构风格和视图；结构化视图；质量视图\n" +
            "Beyond：包含文档路线视图；视图的文档组织方式；系统概述、原理；映射关系",
    },
    {
        question: "描述架构设计中架构模式和策略之间的关系。",
        answer: "① 策略比架构模式更简单；② 架构模式通常由许多策略组合在一起；③ 策略和架构模式共同构成软件设计的工具",
    },
    {
        question: "简述架构设计的几种决策的分类",
        answer: "① 职责分配 ② 协调模型 ③ 数据模型 ④ 资源管理\n" +
            " ⑤ 架构元素之间的映射 ⑥ 绑定时间决策 ⑦ 技术选择",
    },
    {
        question: "在设计软件时应用了哪些通用设计策略？为每个策略提供一个带有软件架构的简明工作示例。",
        answer: "抽象：比如将系统抽象为组件和连接件或抽象为模块。\n" +
            "分解：比如将整个系统分解或将某个模块分解。\n" +
            "分而治之：将每个模块分别处理\n" +
            "生成与测试：将一个特定的设计看作是一个假设；根据测试路径生成测试用例。\n" +
            "迭代与细化：使用ADD方法多次迭代直到满足所有ASRs\n" +
            "复用元素：重用在设计过程中可以复用的元素，重用现有架构",
    },
    {
        question: "简述软件需求、质量属性、ASRs的区别于联系",
        answer: "① 软件需求包含功能性需求与非功能性需求；\n" +
            "② 质量属性是业务目标决定的，是非功能性需求的一种反映；\n" +
            "③ ASRs对于体系结构有深远的影响，是软件需求的一部分。",
    },
    {
        question: "简述架构、结构与设计之间的区别与联系",
        answer: "① 设计包含架构；架构包含结构；\n" +
            "② 结构是静态的；架构是动态的；\n",
    },
    {
        question: "Risks、Sensitivity Points、Trade-off Points分别是什么？各举一例",
        answer: "① Risks：识别风险，发现可能产生负面影响的策略。举例：使用分层模式可能带来性能损耗\n" +
            "② Sensitivity Points：识别敏感点。举例：在对性能敏感的系统中，决定使用缓存中间件\n" +
            "③ Trade-off Points：识别权衡点。举例：使用分层模式可能带来性能损耗，但也会降低耦合度",
    },
    {
        question: "描述ADD的过程",
        answer: "① 确认有足够的需求信息\n" +
            "② 选择要分解的系统要素\n" +
            "③ 确定所选元素的ASRs\n" +
            "④ 选择符合ASRs的设计\n" +
            "⑤ 实例化架构并分配职责\n" +
            "⑥ 为实例化元素定义接口\n" +
            "⑦ 验证和完善需求\n" +
            "⑧ 重复 ②-⑦直到满足全部ASRs",
    },
    {
        question: "描述SOA架构与微服务架构的异同",
        answer: "同：都是分布式架构；微服务是SOA架构的扩展，都包含服务契约、服务封装\n" +
            "异：① 微服务去掉了SOA架构中的ESB；\n" +
            "② 微服务的管理和部署结合了DevOps自动化；\n" +
            "③ 微服务引入API网关和熔断器",
    },
    {
        question: "解释代理架构模式的上下文、好处和局限性",
        answer: "上下文：多个同步或异步交互的远程对象组成的系统，代理模式已定义了运行时组件代理，它协调多个客户机和服务器之间的通讯。\n" +
            "好处：提高了客户端与服务端之间的交互性、提高可伸缩性和可扩展性、解决了单体应用的性能瓶颈、大规模集群的性能提高，但是单点性能会下降。\n" +
            "局限性：代理增加了前期复杂度、可能成为通信的屏障、可能成为攻击的目标、难以测试。",
    },
    {
        question: "简述分层架构模式和多级架构模式的区别\n",
        answer: "① 分层模式是Module Style，而多级模式是Allocation Style\n" +
            "② 分层模式是将任务拆解成处于特定抽象级别的子层次，每层为下一层提供更高层次的服务，核心是关注点分离。\n" +
            "③ 多级模式中的层是逻辑的组合，没有层次模式的强依赖关系，在不同部署环境中分层不同但是软件完成的内容一致。",
    },
    {
        question: "简述软件设计的三个变化维度以及每个维度的变化点",
        answer: "① 面向对象 OOP，强调重用性、灵活性和扩展性。\n" +
            "② 面向方面 AOP，满足扩展的需求，可以在程序中自由的扩展功能\n" +
            "③ 面向服务 SOA，是系统发布功能的一种方式，且基于这种方式下不同的系统之间可以有效的沟通、协作。",
    },
    {
        question: "软件架构的关注点有哪些？其中的利益相关者都有哪些？",
        answer: "软件架构的关注点“\n" +
            "利益相关者；解决的问题；语言，建模技巧；决策，模式\n" +
            "利益相关者：\n" +
            "顾客，用户，架构师，需求工程师，设计师，实施者，测试者，集成者，维护者，产品经理，质量保证人",
    },
]